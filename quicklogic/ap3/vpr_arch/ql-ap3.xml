<!--
 Architecture file for Quick-Logic AP3 architecture
 -->
<architecture>
  <!-- ODIN II specific config -->
  <models>
    <!-- TODO: Add models describing BRAM and Multiplier -->
   <model name="full_adder">
      <input_ports>
        <port name="A" combinational_sink_ports="S CO"/>
        <port name="B" combinational_sink_ports="S CO"/>
        <port name="CI" combinational_sink_ports="S CO"/>
      </input_ports>
      <output_ports>
        <port name="CO"/>
        <port name="S"/>
      </output_ports>
    </model>
    <!-- Flip-flop model used in SLC -->
    <model name="ff">
      <input_ports>
        <port name="QCK" is_clock="1"/>
        <port name="D" clock="QCK"/>
        <port name="QEN" clock="QCK"/>
        <port name="QST" clock="QCK"/>
        <port name="QRT" clock="QCK"/>
      </input_ports>
      <output_ports>
        <port name="CQZ" clock="QCK"/>
      </output_ports>
    </model>
  </models>
  <tiles>
    <tile name="io">
      <sub_tile name="io" capacity="8">
        <equivalent_sites>
          <site pb_type="io" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>
        <fc in_type="frac" in_val="0.200000" out_type="frac" out_val="0.200000">
          <fc_override port_name="outpad" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="inpad" segment_name="l4g" fc_type="frac" fc_val="0.200000"/>
          <fc_override port_name="clock" segment_name="l4g" fc_type="frac" fc_val="0"/>
        </fc>
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="SLC" area="3900">
      <sub_tile name="SLC">
        <equivalent_sites>
          <site pb_type="SLC" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="I0" num_pins="4" equivalent="full"/>
        <input name="I1" num_pins="4" equivalent="full"/>
        <input name="I2" num_pins="4" equivalent="full"/>
        <input name="I3" num_pins="4" equivalent="full"/>
        <input name="I4" num_pins="4" equivalent="full"/>
        <input name="I5" num_pins="4" equivalent="full"/>
        <input name="I6" num_pins="4" equivalent="full"/>
        <input name="I7" num_pins="4" equivalent="full"/>
        <output name="O" num_pins="8" equivalent="none"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.200000" out_type="frac" out_val="0.200000">
          <fc_override port_name="I0" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I1" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I2" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I3" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I4" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I5" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I6" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="I7" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="clk" segment_name="l4g" fc_type="frac" fc_val="0"/>
          <fc_override port_name="O" segment_name="l4g" fc_type="frac" fc_val="0.200000"/>
        </fc>
        <pinlocations pattern="spread"/>
      </sub_tile>
    </tile>
  </tiles>
  <!-- ODIN II specific config ends -->
  <!-- Physical descriptions begin -->
  <layout>
    <!-- Auto layout is for architecture exploration
         TODO: Add BRAM and Multipliers for ap3 device -->
    <auto_layout aspect_ratio="1.0">
      <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100"/>
      <corners type="EMPTY" priority="101"/>
      <!--Fill with 'SLC'-->
      <fill type="SLC" priority="10"/>
      <!--Column of 'mult_36' with 'EMPTY' blocks wherever a 'mult_36' does not fit. Vertical offset by 1 for perimeter.-->
    </auto_layout>
    <!-- TODO: Define a fixed-layout for ap3 device -->
  </layout>
  <device>
    <sizing R_minW_nmos="13090.000000" R_minW_pmos="19086.831111"/>
    <area grid_logic_tile_area="0"/>
    <chan_width_distr>
      <x distr="uniform" peak="1.000000"/>
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <switch_block type="custom"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>
  <switchlist>
    <!-- TODO: the switch definition should follow the external RRGraph definition -->
    <!-- l2s_mux drives length-2 wires on the semi-global metal layer -->
    <switch type="mux" name="l2s_mux" R="878" Cin="2e-15" Cout="0.000000e+00" mux_trans_size="1.5" buf_size="14.2000000">
      <Tdel num_inputs="6" delay="5.65e-11"/>
      <Tdel num_inputs="15" delay="6.84e-11"/>
    </switch>
    <!-- l4g_mux drives length-4 wires on the global metal layer -->
    <switch type="mux" name="l4g_mux" R="448" Cin="1.8e-15" Cout="0.000000e+00" mux_trans_size="1.5" buf_size="20.0000000">
      <Tdel num_inputs="12" delay="5.93e-11"/>
      <Tdel num_inputs="25" delay="7.35e-11"/>
    </switch>
    <!--switch ipin_cblock resistance set to yeild for 4x minimum drive strength buffer-->
    <switch type="mux" name="ipin_cblock" R="3272.5" Cout="0." Cin="2e-15" Tdel="7.562e-11" mux_trans_size="1.2" buf_size="auto"/>
  </switchlist>
  <segmentlist>
    <!-- TODO: the segment definition should follow the external RRGraph definition -->
    <!-- 85% length-2 wires on the semi-global metal layer -->
    <segment freq="0.85" name="l2s" length="2" type="unidir" Rmetal="174" Cmetal="0.0">
      <mux name="l2s_mux"/>
      <sb type="pattern">1 1 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>
    <!-- 15% length-4 wires on the global metal layer -->
    <segment freq="0.15" name="l4g" length="4" type="unidir" Rmetal="23" Cmetal="0.0">
      <mux name="l4g_mux"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 0 0 0</cb>
    </segment>
  </segmentlist>
  <!-- Define custom switch blocks:
       TODO: May check if we can reuse this for ap3 device -->
  <switchblocklist>
    <switchblock name="wilton_turn_core" type="unidir">
      <switchblock_location type="CORE"/>
      <switchfuncs>
        <func type="lt" formula="W-t"/>
        <func type="lb" formula="t-1"/>
        <func type="rt" formula="t-1"/>
        <func type="br" formula="W-t-2"/>
        <func type="tl" formula="W-t"/>
        <func type="bl" formula="t+1"/>
        <func type="tr" formula="t+1"/>
        <func type="rb" formula="W-t-2"/>
      </switchfuncs>
      <wireconn from_type="l2s" to_type="l2s" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l2s" to_type="l2s" from_switchpoint="1" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l4g" to_type="l4g" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l4g" to_type="l2s" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
    </switchblock>
    <switchblock name="wilton_turn_perimeter" type="unidir">
      <switchblock_location type="PERIMETER"/>
      <switchfuncs>
        <func type="lt" formula="W-t"/>
        <func type="lb" formula="t-1"/>
        <func type="rt" formula="t-1"/>
        <func type="br" formula="W-t-2"/>
        <func type="tl" formula="W-t"/>
        <func type="bl" formula="t+1"/>
        <func type="tr" formula="t+1"/>
        <func type="rb" formula="W-t-2"/>
      </switchfuncs>
      <wireconn from_type="l2s" to_type="l2s" from_switchpoint="0,1" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l4g" to_type="l4g" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l4g" to_type="l2s" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
    </switchblock>
    <switchblock name="wilton_straight" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="lr" formula="t"/>
        <func type="bt" formula="t"/>
        <func type="rl" formula="t"/>
        <func type="tb" formula="t"/>
      </switchfuncs>
      <wireconn from_type="l2s" to_type="l2s" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l4g" to_type="l4g" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
      <wireconn from_type="l4g" to_type="l2s" from_switchpoint="0" to_switchpoint="0" num_conns="from"/>
    </switchblock>
  </switchblocklist>
  <!-- TODO: Direct connections across pb_type, may be applied to CI and CO of SLC -->
  <complexblocklist>
    <!-- TODO: Define the bidirectional I/O as the tech lib. -->
    <pb_type name="io">
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <clock name="clock" num_pins="1"/>
      <!-- IOs can operate as either inputs or outputs -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
            <delay_constant max="4.243e-11" in_port="inpad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <delay_constant max="1.394e-11" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
    </pb_type>
    <!-- Define super logic cluster (SLC) begins -->
    <!-- k4 N8 I32 with no input crossbar (but LUT inputs are equivalent
         and each LUT has it's own dedicated inputs) -->
    <pb_type name="SLC">
      <!-- Data inputs to each logic cell -->
      <input name="LI0" num_pins="4" equivalent="full"/>
      <input name="LI1" num_pins="4" equivalent="full"/>
      <input name="LI2" num_pins="4" equivalent="full"/>
      <input name="LI3" num_pins="4" equivalent="full"/>
      <input name="LI4" num_pins="4" equivalent="full"/>
      <input name="LI5" num_pins="4" equivalent="full"/>
      <input name="LI6" num_pins="4" equivalent="full"/>
      <input name="LI7" num_pins="4" equivalent="full"/>
      <!-- Carry input to the 1st logic cell -->
      <input name="CI" num_pins="1"/>
      <!-- Flip-flop control signals -->
      <input name="QEN" num_pins="1"/>
      <input name="QST" num_pins="1"/>
      <input name="QRT" num_pins="1"/>
      <!-- Carry output from the last logic cell -->
      <output name="CO" num_pins="1"/>
      <output name="FZ" num_pins="8" equivalent="none"/>
      <output name="AQZ" num_pins="8" equivalent="none"/>
      <output name="BQZ" num_pins="8" equivalent="none"/>
      <output name="CQZ" num_pins="8" equivalent="none"/>
      <clock name="QCK" num_pins="1"/>
      <!-- BEGIN Describe Logic Cell -->
      <pb_type name="LOGIC_CELL" num_pb="8">
        <input name="LI" num_pins="4"/>
        <input name="CI" num_pins="1"/>
        <input name="QEN" num_pins="1"/>
        <input name="QST" num_pins="1"/>
        <input name="QRT" num_pins="1"/>
        <output name="CO" num_pins="1"/>
        <output name="FZ" num_pins="1"/>
        <output name="BQZ" num_pins="1"/>
        <output name="CQZ" num_pins="1"/>
        <output name="AQZ" num_pins="1"/>
        <clock name="QCK" num_pins="1"/>
        <!-- BEGIN Define 4-input LUT mode -->
        <mode name="LUT">
          <pb_type name="BLE4" num_pb="1">
            <input name="LI" num_pins="4"/>
            <output name="FZ" num_pins="1"/>
            <output name="BQZ" num_pins="1"/>
            <output name="CQZ" num_pins="1"/>
            <output name="AQZ" num_pins="1"/>
            <clock name="QCK" num_pins="1"/>
            <!-- Define LUT -->
            <pb_type name="LUT4" blif_model=".names" num_pb="1" class="lut">
              <input name="in" num_pins="4" port_class="lut_in"/>
              <output name="out" num_pins="1" port_class="lut_out"/>
              <!-- LUT timing using delay matrix -->
              <delay_matrix type="max" in_port="lut4.in" out_port="lut4.out">
                    1.145e-10
                    1.145e-10
                    1.145e-10
                    1.145e-10
              </delay_matrix>
            </pb_type>
            <!-- Define flip-flop -->
            <pb_type name="FF" blif_model=".ff" num_pb="1" class="flipflop">
              <input name="D" num_pins="1" port_class="D"/>
              <input name="QEN" num_pins="1"/>
              <input name="QST" num_pins="1"/>
              <input name="QRT" num_pins="1"/>
              <output name="CQZ" num_pins="1" port_class="Q"/>
              <clock name="QCK" num_pins="1" port_class="clock"/>
              <T_setup value="1.891e-11" port="ff.D" clock="clk"/>
              <T_clock_to_Q max="6.032e-11" port="ff.CQZ" clock="clk"/>
            </pb_type>
            <interconnect>
              <direct name="direct_lutin" input="BLE4.LI" output="LUT4[0:0].in"/>
              <direct name="direct_lut2ff" input="LUT4.out" output="FF.D">
                <!-- Advanced user option that tells CAD tool to find LUT+FF pairs in netlist -->
                <pack_pattern name="ble4" in_port="LUT4.out" out_port="FF.D"/>
              </direct>
              <direct name="direct_qck" input="BLE4.QCK" output="FF.QCK"/>
              <direct name="direct_qst" input="BLE4.QST" output="FF.QST"/>
              <direct name="direct_qrt" input="BLE4.QRT" output="FF.QRT"/>
              <direct name="direct_qen" input="BLE4.QEN" output="FF.QEN"/>
              <direct name="direct_fz" input="LUT4.out" output="BLE4.FZ"/>
              <direct name="direct_aqz" input="FF.Q" output="BLE4.AQZ"/>
              <mux name="mux_bqz" input="FF.Q LUT4.out" output="BLE4.BQZ">
                <delay_constant max="16.6e-12" in_port="LUT4.out[0:0]" out_port="BLE4.BQZ[0:0]"/>
                <delay_constant max="30e-12" in_port="FF[0:0].CQZ" out_port="BLE4.BQZ[0:0]"/>
              </mux>
              <mux name="mux_cqz" input="FF.Q LUT4.out" output="BLE4.CQZ">
                <delay_constant max="16.6e-12" in_port="LUT4.out[0:0]" out_port="BLE4.CQZ[0:0]"/>
                <delay_constant max="30e-12" in_port="FF[0:0].CQZ" out_port="BLE4.CQZ[0:0]"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct_lutin" input="LOGIC_CELL.LI" output="BLE4[0:0].LI"/>
            <direct name="direct_qck" input="LOGIC_CELL.QCK" output="BLE4[0:0].QCK"/>
            <direct name="direct_qen" input="LOGIC_CELL.QEN" output="BLE4[0:0].QEN"/>
            <direct name="direct_qst" input="LOGIC_CELL.QST" output="BLE4[0:0].QST"/>
            <direct name="direct_qrt" input="LOGIC_CELL.QRT" output="BLE4[0:0].QRT"/>
            <direct name="direct_fz" input="BLE4[0:0].FZ" output="LOGIC_CELL.FZ"/>
            <direct name="direct_aqz" input="BLE4[0:0].AQZ" output="LOGIC_CELL.AQZ"/>
            <direct name="direct_bqz" input="BLE4[0:0].BQZ" output="LOGIC_CELL.BQZ"/>
            <direct name="direct_cqz" input="BLE4[0:0].CQZ" output="LOGIC_CELL.CQZ"/>
          </interconnect>
        </mode>
        <!-- END Define 4-input LUT mode -->
        <!-- BEGIN Define adder mode -->
        <mode name="ADDER">
          <pb_type name="BADDER" num_pb="1">
            <input name="A" num_pins="1"/>
            <input name="B" num_pins="1"/>
            <input name="CI" num_pins="1"/>
            <output name="CO" num_pins="1"/>
            <output name="FZ" num_pins="1"/>
            <output name="BQZ" num_pins="1"/>
            <output name="CQZ" num_pins="1"/>
            <output name="AQZ" num_pins="1"/>
            <clock name="QCK" num_pins="1"/>
            <!-- Define Adder -->
            <pb_type name="ADDER" blif_model=".subckt full_adder" num_pb="1">
              <input name="A" num_pins="1"/>
              <input name="B" num_pins="1"/>
              <input name="CI" num_pins="1"/>
              <output name="CO" num_pins="1"/>
              <output name="S" num_pins="1"/>
              <delay_constant max="0.3e-9" in_port="ADDER.A" out_port="ADDER.S"/>
              <delay_constant max="0.3e-9" in_port="ADDER.B" out_port="ADDER.S"/>
              <delay_constant max="0.3e-9" in_port="ADDER.CI" out_port="ADDER.S"/>
              <delay_constant max="0.3e-9" in_port="ADDER.A" out_port="ADDER.CO"/>
              <delay_constant max="0.3e-9" in_port="ADDER.B" out_port="ADDER.CO"/>
              <delay_constant max="0.01e-9" in_port="ADDER.CI" out_port="ADDER.CO"/>
            </pb_type>
            <!-- Define flip-flop -->
            <pb_type name="FF" blif_model=".ff" num_pb="1" class="flipflop">
              <input name="D" num_pins="1" port_class="D"/>
              <input name="QEN" num_pins="1"/>
              <input name="QST" num_pins="1"/>
              <input name="QRT" num_pins="1"/>
              <output name="CQZ" num_pins="1" port_class="Q"/>
              <clock name="QCK" num_pins="1" port_class="clock"/>
              <T_setup value="1.891e-11" port="ff.D" clock="clk"/>
              <T_clock_to_Q max="6.032e-11" port="ff.CQZ" clock="clk"/>
            </pb_type>
            <interconnect>
              <direct name="direct_a" input="BADDER.A" output="ADDER[0:0].A"/>
              <direct name="direct_b" input="BADDER.B" output="ADDER[0:0].B"/>
              <direct name="direct_ci" input="BADDER.CI" output="ADDER[0:0].CI"/>
              <direct name="direct_adder2ff" input="ADDER.S" output="FF.D">
                <!-- Advanced user option that tells CAD tool to find LUT+FF pairs in netlist -->
                <pack_pattern name="adder_ff" in_port="ADDER.S" out_port="FF.D"/>
              </direct>
              <direct name="direct_qck" input="BADDER.QCK" output="FF.QCK"/>
              <direct name="direct_qen" input="BADDER.QEN" output="FF.QEN"/>
              <direct name="direct_qst" input="BADDER.QST" output="FF.QST"/>
              <direct name="direct_qrt" input="BADDER.QRT" output="FF.QRT"/>
              <direct name="direct_co" input="ADDER.CO" output="BADDER.CO"/>
              <direct name="direct_fz" input="ADDER.S" output="BADDER.FZ"/>
              <direct name="direct_aqz" input="FF.Q" output="BADDER.AQZ"/>
              <mux name="mux_bqz" input="FF.Q ADDER.S" output="BADDER.BQZ">
                <delay_constant max="16.6e-12" in_port="ADDER.S[0:0]" out_port="BADDER.BQZ[0:0]"/>
                <delay_constant max="30e-12" in_port="FF[0:0].Q" out_port="BADDER.BQZ[0:0]"/>
              </mux>
              <mux name="mux_cqz" input="FF.Q ADDER.S" output="BADDER.CQZ">
                <delay_constant max="16.6e-12" in_port="ADDER.S[0:0]" out_port="BADDER.CQZ[0:0]"/>
                <delay_constant max="30e-12" in_port="FF[0:0].Q" out_port="BADDER.CQZ[0:0]"/>
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct_a" input="LOGIC_CELL.LI[0:0]" output="BADDER[0:0].A"/>
            <direct name="direct_b" input="LOGIC_CELL.LI[1:1]" output="BADDER[0:0].B"/>
            <direct name="direct_ci" input="LOGIC_CELL.CI" output="BADDER[0:0].CI"/>
            <direct name="direct_qck" input="LOGIC_CELL.QCK" output="BADDER[0:0].QCK"/>
            <direct name="direct_qen" input="LOGIC_CELL.QEN" output="BADDER[0:0].QEN"/>
            <direct name="direct_qst" input="LOGIC_CELL.QST" output="BADDER[0:0].QST"/>
            <direct name="direct_qrt" input="LOGIC_CELL.QRT" output="BADDER[0:0].QRT"/>
            <direct name="direct_co" input="BADDER[0:0].CO" output="LOGIC_CELL.CO"/>
            <direct name="direct_fz" input="BADDER[0:0].FZ" output="LOGIC_CELL.FZ"/>
            <direct name="direct_aqz" input="BADDER[0:0].AQZ" output="LOGIC_CELL.AQZ"/>
            <direct name="direct_bqz" input="BADDER[0:0].BQZ" output="LOGIC_CELL.BQZ"/>
            <direct name="direct_cqz" input="BADDER[0:0].CQZ" output="LOGIC_CELL.CQZ"/>
          </interconnect>
        </mode>
        <!-- END Define adder mode -->
      </pb_type>
      <interconnect>
        <!-- each input connects to its respective LUT with input equivalency -->
        <complete name="completeI0" input="SLC.LI0" output="LOGIC_CELL[0].LI"/>
        <complete name="completeI1" input="SLC.LI1" output="LOGIC_CELL[1].LI"/>
        <complete name="completeI2" input="SLC.LI2" output="LOGIC_CELL[2].LI"/>
        <complete name="completeI3" input="SLC.LI3" output="LOGIC_CELL[3].LI"/>
        <complete name="completeI4" input="SLC.LI4" output="LOGIC_CELL[4].LI"/>
        <complete name="completeI5" input="SLC.LI5" output="LOGIC_CELL[5].LI"/>
        <complete name="completeI6" input="SLC.LI6" output="LOGIC_CELL[6].LI"/>
        <complete name="completeI7" input="SLC.LI7" output="LOGIC_CELL[7].LI"/>
        <!-- clock -->
        <complete name="clks" input="SLC.QCK" output="LOGIC_CELL[7:0].QCK"/>
        <!-- QEN of logic cell can be driven by QEN, QST, QRT of the SLC -->
        <complete name="qen" input="SLC.QEN SLC.QST SLC.QRT" output="LOGIC_CELL[7:0].QEN"/>
        <complete name="qst" input="SLC.QST" output="LOGIC_CELL[7:0].QST"/>
        <complete name="qrt" input="SLC.QRT" output="LOGIC_CELL[7:0].QRT"/>
        <!-- outputs -->
        <direct name="direct_fz" input="LOGIC_CELL[7:0].FZ" output="SLC.FZ"/>
        <direct name="direct_aqz" input="LOGIC_CELL[7:0].AQZ" output="SLC.AQZ"/>
        <direct name="direct_bqz" input="LOGIC_CELL[7:0].BQZ" output="SLC.BQZ"/>
        <direct name="direct_cqz" input="LOGIC_CELL[7:0].CQZ" output="SLC.CQZ"/>
        <!-- Carry chain -->
        <direct name="carry_in" input="SLC.CI" output="LOGIC_CELL[0:0].CI">
          <!-- Put all inter-block carry chain delay on this one edge -->
          <delay_constant max="0.16e-9" in_port="SLC.CI" out_port="LOGIC_CELL[0:0].CI"/>
          <pack_pattern name="chain" in_port="SLC.CI" out_port="LOGIC_CELl[0:0].CI"/>
        </direct>
        <direct name="carry_out" input="LOGIC_CELL[7:7].CO" output="SLC.CO">
          <pack_pattern name="chain" in_port="LOGIC_CELL[7:7].CO" out_port="SLC.CO"/>
        </direct>
        <direct name="carry_link" input="LOGIC_CELL[6:0].CO" output="LOGIC_CELL[7:1].CI">
          <pack_pattern name="chain" in_port="LOGIC_CELL[6:0].CO" out_port="LOGIC_CELL[7:1].CI"/>
        </direct>
      </interconnect>
      <!-- Place this general purpose logic block in any unspecified column -->
    </pb_type>
    <!-- Define super logic cluster (SLC) ends -->
  </complexblocklist>
</architecture>
